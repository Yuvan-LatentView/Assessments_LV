# -*- coding: utf-8 -*-
"""LVADSUSR201_Yuvan Barathi_Clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tEdSvkndFwUV5GEZbdDb_9hZRZPD3-fd
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler, MinMaxScaler, LabelEncoder
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv('/content/customer_segmentation.csv')
df

df.info()

df.isnull().sum()

df.dropna(inplace=True)
df.isnull().sum()

df.duplicated().sum()

# Boxplot to detect outliers
# Identify numerical columns by data type
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Create a box plot for each numerical column
for column in numerical_columns:
    plt.figure(figsize=(10, 6))  # Set the figure size for better readability
    sns.boxplot(x=df[column])
    plt.title(f'Box Plot of {column}')
    plt.xlabel(column)
    plt.show()

#Outlier removal

for column in numerical_columns:
  Q1 = df[column].quantile(0.25)
  Q3 = df[column].quantile(0.75)
  IQR = Q3 - Q1
  data = df[~((df[column] < (Q1 - 1.5 * IQR)) | (df[column] > (Q3 + 1.5 * IQR)))]

data

# Plot the correlation matrix as a heatmap
plt.figure(figsize=(15, 10))
sns.heatmap(data.corr(numeric_only=True), annot=True, fmt=".2f")
plt.title('Heatmap of Correlation Matrix')
plt.show()

data = data.drop(columns = ['Dt_Customer', 'MntMeatProducts', 'MntWines'])
data

label_encoder = LabelEncoder()
data['Education'] = label_encoder.fit_transform(data[['Education']])
data['Marital_Status'] = label_encoder.fit_transform(data[['Marital_Status']])
data

scaler = MinMaxScaler()
scaled_df = data.copy()
scaler.fit(scaled_df)
scaled_df = scaler.transform(scaled_df)
#final_df = scaler.fit_transform(final_df[['imports']])
scaled_df = pd.DataFrame(scaled_df)
scaled_df.columns = data.columns
print(scaled_df.head())

sse = [] # The sum of Squared Errors =SSE
k_rng = range(1,10)
for k in k_rng:
   km = KMeans(n_clusters=k)
   km.fit(scaled_df)
   sse.append(km.inertia_)

plt.xlabel('K')
plt.ylabel('Sum of squared error')
plt.plot(k_rng,sse)

km = KMeans(n_clusters=5)
y_pred = km.fit_predict(scaled_df)
labels = km.labels_
print(y_pred)

scaled_df['cluster']=y_pred
print(scaled_df.head())

silhouette_score(scaled_df, y_pred)